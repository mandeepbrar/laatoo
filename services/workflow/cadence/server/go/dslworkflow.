package main

import (
	"laatoo/sdk/common/config"
	"laatoo/sdk/server/core"
	"laatoo/sdk/server/errors"
	"laatoo/sdk/server/log"
	"reflect"

	"go.uber.org/cadence/activity"
	"go.uber.org/cadence/workflow"
)

/*type activityInput struct {
	taskName string
	initVal  string
	prevVal  string
}

type activityFunc struct {
	taskName string
	activity SimpleActivity
}

type activityResult struct {
	result string
}*/

type SimpleActivity func(args []string) (string, error)

type SimpleWorkflow struct {
	core.Service
	TaskListName string
	WorkflowName string
	Tasks        []string
	//activities   []*activityFunc
}

func (svc *SimpleWorkflow) Initialize(ctx core.ServerContext, conf config.Config) error {
	return nil
}

func (svc *SimpleWorkflow) Start(ctx core.ServerContext) error {
	svc.TaskListName, _ = svc.GetStringConfiguration(ctx, "TaskListName")
	svc.WorkflowName, _ = svc.GetStringConfiguration(ctx, "WorkflowName")
	svc.Tasks, _ = svc.GetStringArrayConfiguration(ctx, "Tasks")
	err := svc.createActivities(ctx)
	if err != nil {
		return errors.WrapError(ctx, err)
	}
	workflow.RegisterWithOptions(SimpleDSLWorkflow, workflow.RegisterOptions{Name: svc.WorkflowName})

	activity.RegisterWithOptions(sampleActivity1, activity.RegisterOptions{Name: "sampleActivity1"})
	activity.RegisterWithOptions(sampleActivity2, activity.RegisterOptions{Name: "sampleActivity2"})
	activity.RegisterWithOptions(sampleActivity3, activity.RegisterOptions{Name: "sampleActivity3"})
	activity.RegisterWithOptions(sampleActivity4, activity.RegisterOptions{Name: "sampleActivity4"})
	activity.RegisterWithOptions(sampleActivity5, activity.RegisterOptions{Name: "sampleActivity5"})

	return nil
}

func actCreator(ctx core.ServerContext, taskName string) {
	log.Error(ctx, "Creating workflow task", "taskName", taskName)
	myFunc := func(args []reflect.Value) (results []reflect.Value) {
		inputargs := args[0].Interface().([]string)
		//inputStruct := args[1].Interface().(activityInput)
		log.Error(ctx, "Completing workflow task", "taskName", taskName, "input", inputargs)
		//activity.GetLogger(actctx).Info("Done", zap.String("taskName", taskName))
		var result string //:= activityResult{""}
		//var err error
		typ := reflect.TypeOf((*error)(nil)).Elem()
		log.Error(ctx, "type of err", "typ", typ) //reflect.Zero(reflect.TypeOf((*error)(nil)).Elem())
		err1 := reflect.Zero(typ)
		log.Error(ctx, "returning result", "result", result, "err1", err1)
		return []reflect.Value{reflect.ValueOf(result), err1}
	}
	var k SimpleActivity
	k = reflect.MakeFunc(reflect.TypeOf(k), myFunc).Interface().(SimpleActivity)

	x, err := k([]string{"r1", "r2"})
	log.Error(ctx, "executed activity kkkk", "x", x, "err", err)

	activity.RegisterWithOptions(k, activity.RegisterOptions{Name: taskName})
	//	return &activityFunc{taskName, retVal.Interface().(SimpleActivity)}
}

func (svc *SimpleWorkflow) createActivities(ctx core.ServerContext) error {
	//svc.activities = make([]*activityFunc, len(svc.Tasks))
	log.Error(ctx, "creating activities", "tasks", svc.Tasks)
	for _, taskName := range svc.Tasks {
		actCreator(ctx, taskName)
		log.Error(ctx, "registered activity", "taskname", taskName)
		//svc.activities[idx] = act
	}
	return nil
}

/*
func (svc *SimpleWorkflow) Workflow(ctx workflow.Context, value string) error {
	ao := workflow.ActivityOptions{
		TaskList:               svc.TaskListName,
		ScheduleToCloseTimeout: time.Second * 60,
		ScheduleToStartTimeout: time.Second * 60,
		StartToCloseTimeout:    time.Second * 60,
		HeartbeatTimeout:       time.Second * 10,
		WaitForCancellation:    false,
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	actLen := len(svc.activities)
	var prevVal = value
	for idx := 0; idx < actLen; idx++ {
		act := svc.activities[idx]
		workflow.GetLogger(ctx).Info("Going to execute activity", zap.String("task", fmt.Sprintf("%s", act.taskName)))
		inp := activityInput{taskName: act.taskName, initVal: value, prevVal: prevVal}
		future := workflow.ExecuteActivity(ctx, act.activity, inp)
		workflow.GetLogger(ctx).Info("Executed activity")
		var result activityResult
		workflow.GetLogger(ctx).Info("Getting result", zap.String("result", fmt.Sprintf("%s", result)))
		if err := future.Get(ctx, &result); err != nil {
			return err
		}
		prevVal = result.result
		workflow.GetLogger(ctx).Info("Done", zap.String("result", fmt.Sprintf("%s", prevVal)))
	}
	return nil
}
*/
